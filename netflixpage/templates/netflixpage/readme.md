Introduction:
For my CS50 Web Programming Final Project, I decided to create a netflix clone that allows
users to browse hundreds of different movies and TV Shows spanning an electic range of genres
from action to horror and science fiction. My love for the movie streaming site netflix and its
wide selection of high quality shows, as well as an intriguing wonder of how Netflix's site was built led me to embark on this project. Although this project does not achieve all the functionalities of Netflix (which I personally feel is reasonable given that Netflix was built by hundreds of professional
and highly capable software engineers who were working full-time to build the site), my netflix clone
achieves the main functionalities. These include: displaying real time movie data (eg images, short video trailers, movie titles, movie ratings, release date, movie summary and genres for each movie) from a wide range of genres such as thriller, romance, comedy and many more, enabling users to like movies and add movies to watchlist, as well as search for movies based on their title, genres or overview. All in all, this project is one that I poured weeks of effort and commitment into, and is one that has honed my web programming skills tremendously and I am proud of this capstone project.


Documentation of what I did: Initially when I first started the project, I struggled slightly with designing an aesthetic webpage/ ensuring my webpage was aesthetically pleasing like Netflix. Thus, I decided to use a combination of regular CSS, Tailwind CSS, Bootstrap, and Font Awesome CSS to enhance the visual appeal of my site. Tailwind CSS was primarily used due to its wide range of pre-defined utility classes and high customizability. This allowed me to quickly build the general layout and user interface of my webpage, by styling various components such as navigation bars, a footer, and a main div to display the movie data.

After I created the general layout of my page, I wanted to design various components to welcome the user and provide more insights to the function and utility of my page before users are signed in. These welcome components were designed to resemble Netflix's page, and can be found at the top of the "index.html" file in the "templates\netflixpage" folder. However, I also improvised and added new functionalities, such as creating animations that enlarged various images in the <Div /> react component once the user scrolled downwards to these images. This was achieved by using the Intersection Observer API to detect when the image appeared on the user screen, as well as the React "useState" Hook to alter the state once the image is visible so as to load the animation. The animation I wrote can be found in the style tag of the "layout.html" page.

Next, I wanted to design scrolling movie cards - similar to the actual Netflix Site. I used React to build my scrolling movie cards component, to enable reusability of the component and allow myself to easily manage and reuse code. I designed it such that each movie card will initially only display an image for the movie, however upon hovering over the image, a new div would pop up displaying additional details such as title, overview of movie, genres and rating of movie. 

As I wanted to display real time movie data for movies that are currently popular on Netflix, I used the Movie DataBase (TMDB) API. My React movie cards component made a fetch request to a Django URL endpoint I constructed, and I wrote a backend Django function related to this Django url. This django "retrieve" function then made various API calls to the TMDB API, to retrieve various information. It retrieved various genres and their ids using the TMDB API, before saving the information in a GenresMovies Django Model I created. The function also retrieved movie data for a specific genre, saving relevant information such as the title, rating, overview, imageurl, and a video url(containing link to short youtube trailer for that movie). These information were then saved in a Movies Django model I created. The django function then filtered through Movies Model for movies with a certain genre, creating a list of dictionaries, where each dictionary contained detailed information for a single movie for a specific genre. It finally returned a JSONresponse of this list of dictionaries to the React movie cards component. I created a "moviedata" state for the react movie cards component, the "moviedata" state was set to the list of dictionaries JSONresponse. The map function was then used to create a div/moviecard for every movie in the "moviedata" state, displaying relevant information for each movie. 

As I wanted to display TV shows as well, I reused my React movie cards component and edited it accordingly in order to display TV shows apart from movies. I repeated the process in the previous paragraph, creating additional django Models, Functions and URLs/Endpoints linked to the React TV Show Cards Component, and making separate TMDB API calls to retrieve data for TV shows as well. The TV Shows data was then displayed in the React TV Shows movie cards. I also added functionality such as enabling users to like movies/TV Shows and add them to watchlist, as well as search for Movies/TV shows. These were done by writing React Client side functions and Django server side functions, to update Django databases as well as dynamically display information in React components.


Complexity: I believe my project is sufficiently complex and of greater complexity than the other projects in this course owing to the following reasons:

1. Use of Real Life Data and greater Real Life Applicability:
Most of the other projects in this course do not make use of any real life data as the data and information displayed are provided by the user (except Project 0: Search where users can be directed to Google's actual website based on their search query). For example, in Project 4 (network), the posts are created entirely by users of the site with little to no real time data being used to create the posts. In project 2 (commerce), again the details for the Auctions Listings are provided by the user with little use of real life data (except perhaps for the image url to a Google Image for the listing).

However, in my final project, there was extensive use of real life and real time data. I made multiple API calls to the Movie Data Base (TMDB) API to retrieve data for a vast array of in-demand Movies and TV Shows that actually exist in real life and are currently popular. Additionally, data for genres and their respective ids was also retrieved from the TMDB API and saved in my own Django database. These data were then displayed in my React Scrolling Cards for Movies and TV Shows. Every Movie Card displays real life and real time data for a specific movie, unlike other projects which do not display much real life data. On account of this factor, I believe my project has greater real life applicability in terms of greater potential for adoption and use by other people in real life.

2. Greater Integration of Client Side (Front End) and Server Side (Backend) Development:
My project clearly integrates the front and back ends more extensively than the other projects. The scrolling movie and TV Shows cards React Components make a fetch request to various Django URL Endpoints I constructed, which calls various corresponding Django functions in views.py. The django functions then make API calls to the TMDB API to retrieve real time movie and TV Shows data, and data for various genres. All these data retrieved are then saved in my Backend Django Models that I created. The Django functions then filter through the Django Models to retrieve movies/TV Shows of a certain genre/that are added to user's watchlist, before sending a JSON Response of these movies/TV Shows to the React front end scrolling movie cards components. The components then make use of the useState React Hook to update the state of the component, and also use the "map" function to create a div for each movie that displays details retrieved from TMDB API and my backend database. 

In contrast, other projects in the course definitely have much lesser linkage/integration of the front end and back ends.

3. More extensive use of Backend Django Database
My project saves over 800+ real life movies and TV shows into the backend Django "Movies" and "TVShows" databases, and my webpage displays all of these 800+ movies and TV Shows. In contrast, all the other projects typically have less than 50 entries in the databases. For example, Project 3 (Mail) only displayed less than 50 emails on the webpage, and Project 2 (commerce) displayed less than 20 auctions listings on the webpage. 

4. Ability to like/unlike movies, add/remove movies from user's watchlist, dynamically show and hide movie trailers, and search for movies based on keywords relating to genres, titles or overview
My webpage has buttons to like movies or add them to watchlist, as well as buttons to view movie trailers. Once these buttons are clicked, the text displayed within the buttons will be dynamically updated by sending fetch requests or AXIOS POST request to the backend, which then returns a JSON response of the updated button message. Additionally, once the button to view movie trailers is clicked, a youtube video iframe will be shown within the movie card, and users can play the video to watch trailer. Users can also search for movies by title, genre or overview, and will be redirected to a page containing movies matching the search query. I used the Q object in Django to perform advanced database lookups, filtering through the Movies and TVShows Objects to return movies and tvshows whose attribute(s) contained the user's search query.


Distinctiveness: This project is definitely rather distinct from all the previous projects from this course. Unlike project 4 (Network) which is a twitter-like social network website for making posts and following users, my project is a streaming platform offering short video content for on-demand viewing, and its primary focus is on delivering entertainment content rather than facilitating social interactions and connections between users. Due to the same aforementioned reason, my project is definitely distinct from an email website allowing users to send and receive emails (Project 3 - Mail). Neither is my project similar to an ecommerce site allowing users to post Auctions Listings for sale (Project 2 - Commerce), as the goal of my website is to provide short video entertainment content rather than allow users to upload items(auctions listings) to the website and interact with other user's items (through bidding). My project is clearly not a Wikipedia-like online encyclopedia (Project 1-Wiki) or a Google Search Engine (Project 0 - Search), as its purpose and intent is to provide short form entertainment in the form of videos to users, rather than provide information to user's queries. Although my project does allow some search functionality (where users can search for movies based on title, genres or their overview) and might be deemed similar to project 0 and 1 in this regard, the clear difference in the nature and purpose of my website makes it ultimately very distinct.


Files I created:
The "Netflixpage" folder is the Django App I created for this project to build the website. Within "Netflixpage", the "templates\netflixpage" folder contains the different html pages on my website. "layout.html" contains the general html layout and structure used for all the different pages, 
"index.html" is the homepage once the user logs in which displays various movies of different genres,
"login.html" is the login page,
"register.html" is the webpage for users to register for an account,
"searchpage.html" is the page users are directed to upon searching for a movie, page contains movies related to user's search query,
"tvshows.html" displays all the tv shows,
"liked.html" is webpage that displays all the movies/tvshows that user liked,
"watchlist.html" is webpage that displays movies/tvshows in user's watchlist.

The "static\netflixpage" folder contains different images used in my webpage, as well as a styles.css file for general CSS styling.

The "apitest.py" files contains short code to test the TMDB API request and responses to check and validate that the API links are working and returning responses containing the relevant data.

"models.py" file contains the different models I wrote in Django.

"urls.py" contains different Django URLs I wrote, while "views.py" contains different django functions corresponding to the diff URLs.


How to RUN Application:
To run the application, simply download the files from this github repository branch, and run the django server. You should see a welcome page and under the "Unlimited Films, TV Programmes and More!" section, enter your email address and click "Get Started". You should be directed to the register page, where you can enter your details to register. You can then login using the details you registered with, and you should be directed to the homepage with various movies.

As I have already included my API Keys and authorization headers when making the TMDB API calls, the movies should be retrieved from the TMDB Database, and saved to the Django Models in this project once each page loads. However, due to the large volume of movies being retrieved from the API, its not possible to retrieve all the movies and tvshows (over 900 movies and tvshows) all at once. Hence, YOU MUST RENDER THE MOVIE CARD COMPONENTS 3 AT A TIME FROM LINES 638 TO 678 IN INDEX.HTML, AND RENDER THE TVSHOW CARD COMPONENTS 2 AT A TIME FROM LINES 447 TO 481 IN TVSHOWS.HTML. (meaning that you render first 2 or 3 movie card components and wait for those movies to be saved to django database on your instance of this project before rendering the next 2 or 3, together with those that have already rendered and saved)

In the event that the movies are not displayed at all, you might have to obtain your own API Keys and authorization headers by signing up for an account at https://www.themoviedb.org/signup . The lines in views.py where you might have to fill in your own API Keys/authorization headers are lines 52,75,90,181,208 and 225.



